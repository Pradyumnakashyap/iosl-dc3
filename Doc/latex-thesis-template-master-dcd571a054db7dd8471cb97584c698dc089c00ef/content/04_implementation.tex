\chapter{Implementation}
\label{cha:implementation}

In the chapter we explain how the implementation is done for both the frontend and the backend sides.
We first elaborate on the different roles exist in the frontend:

\section{Frond-end}

\textbf{IDE}: Visual Studio code\\
\textbf{Language}: React\\
\textbf{Libraries used}:
\begin{itemize}
    \item react-router-dom
    \item receiver mail must be a register user
\end{itemize}


\subsection{Costumer}
Libraries used:
\begin{itemize}
\item rc-slider for creating the tempatrue slide bar 
\item react-horizontal-timeline for the time line
\item redux-form for the registration form
\end{itemize}

The costumer role refer to any individual who send a package through the system.
The costumer has the following abilities:

\begin{itemize}
    \item register a package
    \item delete a package
    \item show a package detail view 
    \item time line
\end{itemize}


\subsubsection{Register a package}
The register package process divided by two component:
\begin{itemize}
\item RegisterPackage.js - view (child)
\item UserSpace.js - controller (father)
\end{itemize}


\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{images/register.jpg}
	\caption{register package process, component diagram}
	\label{fig:}
\end{figure}


The component ResgiterPackage is an assembly of Redux <Field> component and React input.
for each input field the user enter, the page is rendered and the state is updated
The form contain the following validation:
\begin{itemize}
\item no text input filed can be left empty 
\item receiver mail must be a register user
\end{itemize}
i.e without standing in the form requirement, the user can not press the submit button.

When registering a package, a sensor data may be provided by clicking the correspond checkbox. It is import to mention that not every package has a sensors data.\\
HTTP requests arrive from the browser at the backend are integral part to insure system operation
After pressing the sumbit button the following occures:\\
1. \textbf{http://localhost:8000/address} post request to enter the address and get back and ID for each user\\
2. \textbf {http://localhost:8000/packages}  post request to enter the packages to the packages tables, return a package \\
3. \textbf {http://localhost:8000/OrderSensors}  post request to enter the sensors (if exist)  to the sensore table, return a sensore id\\
4.\textbf {http://localhost:8000/OrderHistory}  post request to enter the action(registration) as part of the order history for later on use in the time-line\\

\subsubsection{cancel package}
The feature cancel package allows the user to delete a cancel package.
After pressing the navbar "delete package" option, the user will be directed to the Activs.js compnent.\newline
The user will be shown only packages in a "register" status, \textbf{any other package which has being dispatch already can not be cancel}.\newline
From the system perspective while the package is being canceled, the data is not deleted from storage,it will only be marked as canceled. algorithm:
\begin{enumerate}
  \item \textbf{http://localhost:8000/packages/user/}  get request before component moount: upload all packages with "register" status
  \item if user press delete:
  \begin{enumerate}
      \item textbf {http://localhost:8000/packages/:id}  put request to change the spesific package to "cancel" mode.
      \item textbf {http://localhost:8000/OrderHistory}  post reqest. update the timeline, add the event to history
\end{enumerate}
\end{enumerate}

\subsection{Postman}
\textbf{Overview of the functionality:}

Postman user in the system will be able to do the following activities:-
\begin{itemize}
\item {\textbf{View all the packages that have been assigned to him: }}(PostmanTableWithLinks.js) When the Company user assigns a package (PackageId) to a particular postman (PostmanId) then a relevant record is created into the table orderHistory. All the packages that are assigned to the current user are fetched using http://localhost:8000/orderHistory

\item \textbf{View the information about the package such as pickup address, drop address, status etc:} The table orderHistory contains columns that hold the relevant data of the package required for the postman to identify every package.
\item \textbf{Able to change the status of the package as Delivered once the actual delivery has been made:} whenever a postman physically delivers the package to the recipient at the respective Drop Address, then he is able to press the button 'Deliver' that invokes the function to setthe status of the Package as 'Delivered' and enter a new row in the packageHistory table only to denote that the package is now counted as one of the delivered packages.
\item \textbf{Able to Handover the package by assigning it to another Postman and change the status accordingly: }whenever a postman reaches an intermediate point in the route of the package where he has to hand it over to another postman, then the 'Handover' button is used to redirect to another component HandoverForm.js where the user id of the receiving postman needs to be entered. This functionality allows one postman to assign a package to nother postman by changing the 'AssignedTo' data in the relevant table. After this subroutine is invoked the handed over parcel  starts to appear in the dashboard of the receiving postman.
\item \textbf{Able to raise Incident whenever there is any violation of policies:} A postman to who the package has been assigned or handed over is able to judge the condition of the package and raise an incident mentioning the details of the package and the nature of violation also mentioning its current condition using the form created in the Incident.js component.
\item \textbf{View the Incidents that have been raised in the past: }Under the heading 'Incident Management' there is a link 'View Incidents' that redirects to ViewIncidents.js component that pulls data from the Incidents table and allows the Postman to see the relevant list of Incidents raised by or against him that have not yet been resolved.
\end{itemize}

\begin{figure}[htp]
    \centering
    \includegraphics[width=4cm]{images/snet/DC3 Postman.png}
    \caption{DC3 Postman}
    \label{fig:}
\end{figure}





\section{Back-end}
Back-end or server is a layer on top of the database and Blockchain for the front-end. It does handle the authentication and authorization and does take care of fetching and sending data to the hyper-ledger fabric. We are using following technologies 

\textbf{IDE}: Visual Studio code\\
\textbf{Language}: JavaScript\\
\textbf{Frameworks}: NodeJS with Express



\subsection{Project Structure}
Project structure has is modular and functionality has been divided into folder based on functionality. Hence we have two major folders at the root, server and test, with some other application level files 


\begin{figure}[htp]
    \centering
    \includegraphics[width=4cm]{images/directystructure.png}
    \caption{Directory Structure}
    \label{fig:}
\end{figure}

\begin{itemize}

\item {\textbf{Server}}: This folder contains all the logic related to server functionality. 
\begin{itemize}
\item {\textbf{Config}}: This folder contains the configuration for the server side. authkeys.js does contain the secret keys used across the application for google social login and to generate the token for authorization. Passport.js contains the logic for google strategy. we can write another strategy in the same file as well e.g. github or local strategy. In future, When we are going to integreate the platform with different vendors, we will be using the local passport strategy using the vendor database. After that, route.js does contain all the routes for the application. any new routes needs to be registered in this file. Finally token.util.js contains utility functions to generate and send the token to the client back. It also exposes the method to generate the token which is used for mocked unit testing. 

\item {\textbf{lib}}: Library or lib folder does contain the middleware for our back-end application. Right now we have only one, secureMiddleware, to secure our API endpoints. It does check if access-token header is provided in rquest body, cookie or querystring and then decode it using our secret. If successful it will set the user profile on the request object, otherwise throw 401 response. 

\item {\textbf{models}}: Models folder does contain all the different models to fetch the data from database or block chain. Each file represent an entity in the system or a related database relation.  Furthermore, index.js file contains the references of all the models and is used almost everywhere in the system as single reference point for the models. 

\item {\textbf{SQL}}: SQL folder contains the database schema which can be used to deploy or create the database while setting up a project on a new machine. Additionally, it contains a schema file to generate the database diagram on dbdiagram.io as well. 
\end{itemize}


\item {\textbf{test}}: This folder contains all the unit tests. Each file contains the tests for the respective model file. Test does use mocha and chai frameworks.

\item {\textbf{env}}: .env is environment file to setup variables at the start of the project instead of reading from the config file, it will be read from the environment. This file is git ignored. It isn't used at the moment as we are reading db config from the db.js directly for now. 

\item {\textbf{eslintrc.json}}: ESlint configuration can be changed using this file. We are using Airbnb base syntax for our linting.  

\item {\textbf{gitignore}}: GitIgnore is used to tell git which files we don't want to store in the source control. 


\item {\textbf{package.json}}: This file contains all the configuration to setup the project. When we do npm install, it will read this file and install all the package on end user machine. It also contains the dev dependencies. We have different scripts configured to run e.g. running the server or run server in the debug mode, run linter. 

\item {\textbf{server.js}}: This is the starting file where our project starts. This file will bootstrap the application by configuring different modules, followed by loading the routes and then running the http server on specific ports. We also configure the express server, body parser (which parse the request body), cookie-parser, passport js and most importantly CORS to send cross origin requests.   

\end{itemize}

\subsection{Unit Testing}
We are using mocha framework for unit and integration testing in our project. Additionally we have used chai as an assertion framework for our tests. Each test has a title or test case description followed by request and expected results. A sample test is as follows

\begin{verbatim}
  /*
  * /GET company/id
  * Test the single company records from the database
  */
  it('It should GET single company', (done) => {
    chai.request(server)
      .get('/company/2')
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('array');
        res.body.length.should.be.eql(1);
        done();
      });
  });



\end{verbatim}

We used chai request to call the endpoint, set the access token for the secured endpoints, and then compare the results with  the expectation. We also have tests which will send different access token to validate the authorization of the endpoints e.g. postman can see only packages assigned to him and not all the packages or a customer cannot request a handover for a package. 

